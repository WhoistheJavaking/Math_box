git :  버전관리
github : 원격 저장소

1. 리파지토리(저장소)
 - 프로젝트 디렉토리(숨겨진 디렉토리)
 - 커밋이 저장되는곳

2. 커밋
 - 프로젝트 디렉토리의 특정 모습을 하나의 버전으로 남기는 행위 
 - 주의사항
 1) 처음으로 커밋을 하기 전 사용자의 이름과 이메일 주소 설정
  - git user.name "~~"
  - git user.email "~~"
 2) 커밋메시지 남기기 옵션(-m)
 3) 어떤 파일을 커밋에 반영할지 지정해줘야함
  - git add

1. working directory에서 A.txt 파일과 B.txt 파일을 작성하고 
2. git add A.txt와 git add B.txt를 실행해서 A.txt, B.txt 둘다 staging area에 올렸습니다.
3. 그 다음 git commit -m "Ver_1"를 실행해서 staging area에 있는 파일들을 가져와 커밋으로 남겼습니다. 


이번 챕터에서 배운 커맨드들을 정리해볼게요.

git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
git config user.name 'codeit' : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)
git config user.email 'teacher@codeit.kr' : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보)
git add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기
git add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기 
git add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기
git reset [파일 이름] : staging area에 올렸던 파일 다시 내리기
git status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음) 
git commit -m "커밋 메시지" : 현재 staging area에 있는 것들 커밋으로 남기기
git help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력
앞으로 각 챕터에서 새롭게 배운 커맨드들은 이렇게 정리하고 넘어가겠습니다.


이번에는 브랜치(branch)에 대해 좀더 많은 것들을 배워보겠습니다.

여러분, 혹시 3. GitHub 시작하기 챕터의 '02. Local Repository의 내용을 Remote Repository로 보내기' 레슨에서 했던 작업, 기억나시나요?

저는 그때

GitHub에서 Math_Box라는 리모트 레포지토리(remote repository)를 만들고
로컬 레포지토리(local repository)의 내용을 그 리모트 레포지토리에 보내기위해 아래와 같은 커맨드 2개를 실행한 적이 있습니다. 
git remote add origin https://github.com/kyuri-dev/Math_Box.git
git push -u origin master 
그 때는 이 2개의 커맨드를 그냥 복사-붙여넣기해서 실행만 하고 정확한 의미에 대해서 설명하지 않았는데요. 이번 노트에서는 그 의미를 알아보겠습니다. 

1. origin이란?
먼저 첫 번째 커맨드를 봅시다. 

git remote add origin https://github.com/kyuri-dev/Math_Box.git
이 커맨드에서 remote는 리모트 레포지토리에 관한 작업을 할 때 쓰는 커맨드입니다. 

그리고 그 뒤의 add는 새로운 리모트 레포지토리를 등록하겠다는 뜻입니다. 

그 다음에는 origin https://github.com/kyuri-dev/Math_Box.git이라고 써있죠?

이 표현은 https://github.com/kyuri-dev/Math_Box.git 리모트 레포지토리를

origin이라는 이름으로 등록하겠다는 뜻입니다.

그러니까 이 커맨드를 실행하고 나면 https://github.com/kyuri-dev/Math_Box.git를 origin으로 간단하게 나타낼 수 있게 되는 거죠.

그럼 왜 하필 origin이라고 하는 걸까요? origin이 아닌 여러분이 원하는 다른 단어를 입력해도 큰 상관은 없습니다. 하지만 Git에서는 리모트 레포지토리를 최초로 추가할 때 origin이라는 이름으로 가리키는 것이 관례화되어 있습니다. 

origin은 ‘근원’, ‘기원’이라는 뜻을 가집니다. 아마도 다른 사람의 리모트 레포지토리를 자신의 컴퓨터로 가져와서 작업을 하는 사람의 입장에서는 리모트 레포지토리가 프로젝트의 근원이 되는 존재이기 때문에 그런 관습이 생긴 것으로 추측됩니다. 

사실

 git remote add hello https://github.com/kyuri-dev/Math_Box.git
처럼 origin 대신 우리가 원하는 단어(hello)를 써도 상관은 없지만, 되도록 관례에 따라 origin을 써주는 게 좋겠죠?

2. Remote Repositoy에 있는 브랜치
이제 두 번째 커맨드를 설명해드릴게요. 

git push -u origin master
이 커맨드의 뜻은 

현재 로컬 레포지토리에 있는 master 브랜치의 내용(=master 브랜치와 관계된 모든 커밋들)을
origin이라는 리모트 레포지토리로 보낸다는 뜻입니다.
이때 같은 이름의 브랜치로 전송하게 되는데 만약 origin이라는 리모트 레포지토리에 master 브랜치가 없으면 master 브랜치를 새로 생성하고 푸시합니다. 

그런데 여기서 옵션 -u는 무슨 뜻일까요? -u는 --set-upstream이라는 옵션의 약자입니다. 

이렇게 --set-upstream(-u) 옵션을 주면 

로컬 레포지토리에 있는 master 브랜치가 
origin에 있는 master 브랜치를 tracking(추적)하는 걸로 설정됩니다. 
tracking이라는 건 로컬 레포지토리의 한 브랜치가 리모트 레포지토리의 한 브랜치와 연결되어 그것을 계속 바라보는 상태가 되는 것이라고 생각하시면 됩니다. 이렇게 맺어진 연결 상태를 tracking connection이라고 합니다. 

만약 

로컬 레포지토리에 A라는 브랜치가 있고,
리모트 레포지토리에 B라는 브랜치가 있을 때 
이런 tracking connection이 서로 맺어진 경우,
B 브랜치를 A 브랜치의 upstream branch라고 합니다. 
지금은 구별하기 위해서 A와 B라고 표현했지만 보통은 같은 이름인 경우가 대부분입니다.
이렇게 tracking connection이 한번 설정되고 나면,

사용자가 현재 master 브랜치에 위치해있을 때,

git push
라고만 써도 자동으로 리모트 레포지토리의 master 브랜치를 대상으로 git push가 동작하고,

git pull 
라고만 써도 리모트 레포지토리의 master 브랜치를 대상으로 git pull이 동작합니다. 

사실 --set-upstream(-u) 옵션을 주지 않아도 그 후에 git push와 git pull을 할 수 있기는 합니다. 하지만 맨 처음에 이 옵션을 주지 않으면 tracking connection이 없기 때문에 나중에 git push를 하고 싶을 때

git push origin master:master 
이런 식으로 적어줘야 합니다. 여기서

origin은 리모트 레포지토리를 나타내고,
master:master에서 더 먼저 나오는 master는 로컬 레포지토리의 master 브랜치(~에서)/더 뒤에 나오는 master는 리모트 레포지토리의 master 브랜치(~으로)를 나타냅니다.
그러니까 tracking connection이 없으면 매번 이런 식으로 git push를 해줘야 합니다. git pull도 마찬가지로 이런 식의 복잡한 표현이 필요하게 됩니다.

그러니까 그냥 처음부터 tracking connection을 설정하고 그 이후부터는 git push, git pull이라고만 써서 편하게 푸시와 풀을 하는 게 좋겠죠? 이게 바로 제가 맨 처음에 로컬 레포지토리의 내용을 리모트 레포지토리로 보낼 때 -u라는 옵션을 썼던 이유입니다.

3. origin/master의 의미
자, 이제 

로컬 레포지토리의 master 브랜치 
리모트 레포지토리의 master 브랜치 
이렇게 같은 이름이지만, 서로 다른 2개의 브랜치가 있다는 걸 알겠죠? 

그럼 리모트 레포지토리에 있는 master 브랜치는 어떻게 볼 수 있을까요? GitHub 페이지에서 보면 될 겁니다.

하지만 제 컴퓨터에서도 확인할 수 있는 방법이 있습니다. 잠깐 커밋 히스토리를 살펴보면



위 그림에서

master가 로컬 레포지토리의 master 브랜치를 나타내고
origin/master가 리모트 레포지토리의 master 브랜치를 나타냅니다. 
이때까지 로컬 레포지토리의 master 브랜치에서 여러 커밋을 했지만 그러고나서 git push를 해준 적은 없었습니다. 그래서 위 그림처럼 origin/master가 master보다 이전의 커밋을 가리키고 있는 겁니다.

다음 영상에서는 master, premium 브랜치 둘 다에서 리모트 레포지토리로 git push 하겠습니다. 그러고 나면 이제 origin/master도 master와 같은 커밋을 가리키게 될 것입니다.



이전 영상에서는

사실 브랜치(branch)는 커밋을 가리키는 존재(포인터)이고, 
HEAD는 이런 브랜치를 통해 커밋을 간접적으로 가리키는 존재(포인터)
라고 배웠습니다.

자, 이제 이 사실을 안다면 우리가 이전에 배운

git reset
커맨드의 동작 원리를 더욱 정확하게 알 수 있는데요.

1. git reset을 할 때 HEAD의 변화는?
지금 총 4개의 커밋을 한 아래와 같은 상황이라고 가정합시다.



현재 각 박스 안에 있는 텍스트는 각 커밋의 커밋 아이디 앞 부분입니다.

이 상태에서

git reset [--hard 또는 --soft 또는 --mixed] 9033
을 실행한다면 어떻게 될까요? 이전에 git reset을 배울 때를 떠올려보면 HEAD가 9033.. 커밋을 가리키게 되겠죠? 그럼 정확히 어떤 모습으로 가리키게 되는 건지 보여드리겠습니다. 어떤 옵션을 쓰든 아래 그림과 같은 결과가 됩니다.



지금 HEAD는 여전히 master 브랜치를 가리킵니다. 대신 master 브랜치가 가리키던 커밋이 바뀌었네요. 그래서 결과적으로 HEAD가 9033.. 커밋을 가리키게 된 겁니다.

방금 발생한 일을 정리하면 다음과 같습니다. git reset 커맨드를 사용하면 

HEAD는 여전히 같은 브랜치를 가리키고, 
HEAD가 가리키는 브랜치가 다른 특정 커밋을 가리키게 됩니다.
이 때문에 결국 HEAD가 간접적으로 가리키던 커밋도 바뀌게 되는 겁니다.
git reset을 했을 때 HEAD가 가리키던 커밋이 바뀐다는 말이 정확히 무슨 뜻인지, 이제 아시겠죠? 바로 이런 원리가 있었던 겁니다. 그리고 이전에 배운대로 각 옵션(--soft/--mixed/--hard)에 따라 과거의 커밋처럼 working directory나 staging area도 리셋되는지가 결정되는 거구요.

하지만 한 가지 더 알아야할 git reset의 비밀이 있는데요.

2. git reset을 한다고 그 이후의 커밋이 사라지는 건 아닙니다.
git reset을 한다고 하면 그 이후의 커밋이 삭제되는 것으로 착각하기 쉽습니다. 그러니까 위 상황에서 네 번째 커밋인 43kf.. 커밋이 사라진다고 오해하실 수도 있는데요. 전혀 그렇지 않습니다. 43kf.. 커밋은 계속 남아있습니다.

그리고 git reset은 꼭 과거의 커밋으로만 할 수 있는 것도 아닙니다. 현재 HEAD가 가리키고 있는 커밋 이후의 커밋으로도 리셋할 수 있죠.

지금처럼 HEAD가 3번째 커밋인 9033.. 커밋을 가리키고 있는 상태에서 
git reset 43kf
를 실행하면 master 브랜치가 다시 43kf.. 커밋을 가리키게 됩니다. 아래 그림처럼요.



그러니까 git reset에 관해서 분명하게 아셔야할 게

과거의 커밋으로 git reset을 한다고 그 이후의 커밋들이 삭제되는 게 절대 아닙니다. 계속 남아있습니다. 
git reset은 과거의 커밋뿐만 아니라 현재 HEAD가 가리키는 커밋 이후의 커밋으로도 할 수 있습니다. 
이 사실을 확실히 알고 나면 앞으로 git reset을 사용해서 커밋 사이를 자유자재로 이동할 수 있을 겁니다.

이번 챕터에서 배운 커맨드를 정리해봅시다.

git branch [새 브랜치 이름] : 새로운 브랜치를 생성
git checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
git branch -d [기존 브랜치 이름] : 브랜치 삭제
git checkout [기존 브랜치 이름] : 그 브랜치로 이동
git merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지
git merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감